# Price and avaiability

本頁將解釋在Oscar中價格與可得性是如何決定的。簡短說，這似乎有些複雜。

### Overview

簡單的電子商務框架通常直接將價格綁到產品模型上。
(也就是價格只是產品的一個屬性)
```python
product = Product.objects.get(id=1)
product.price
Decimal('17.99')
```

Oscar則是另一種方式，自庫存紀錄中將產品區分出來，並以一個可包裝的策略`strategy`來選定適當的庫存策略\計算價格及可得性資訊。

```python
# 載入選擇器，策略是選擇器實例的一方法，產品資訊是將策略綁到產品的一結果
>>> from oscar.apps.partner.strategy import Selector
>>> product = Product.objects.get(id=1)
>>> strategy = Selector().strategy()
>>> info = strategy.fetch_for_product(product)

# 可得性訊息
# Availability information
>>> info.availability.is_available_to_buy
True
>>> msg = info.availability.message
>>> unicode(msg)
u"In stock (58 available)"
>>> info.availability.is_purchase_permitted(59)
(False, u"A maximum of 58 can be bought")

# 價格訊息
# Price information
>>> info.price.excl_tax # excel_tax 不含稅價格
Decimal('17.99')
>>> info.price.is_tax_known # is_tax_known 稅金是否已知
True
>>> info.price.incl_tax # 含稅價格
Decimal('21.59') 
>>> info.price.tax  # 稅金金額
Decimal('3.60')
>>> info.price.currency # 貨幣種類
'GBP'
```
產品模型紀錄了關於產品的核心數據(抬頭\描述\照片)，而庫存紀錄呈現一個特定夥伴的供應訊息(在庫數量\基礎價格)，一種產品可以有多個庫存紀錄，但只有一個被策略選擇以決定價格與可得性。

藉由使用你自己的客製策略類別，價格\稅\與可得性的一大範圍的問題將可以輕易的解決。

### 策略類別
Oscar使用一個策略物件來決定產品可用性與價格。一個新的策略實例由購物籃中間件指給一個request。一個`Selector`類別為request決定適當的策略。藉由修改`Selector`類別，可以為不同的消費者提供不同策略。

對一個產品，策略類別用來
* 選擇`價格政策`，一個物件用來決定產品價格與是否已知稅額。
* 選擇`可用性政策`，一個物件用來負責可用性邏輯。
* 針對供貨商選擇適當的庫存紀錄來使用，假如一種產品可以由數個供貨商提供，個別的供貨商有自己的庫存紀錄。

在`PurchaseInfo`物件中包著三個實體，物件本身只是一個具名的tuple，策略類別提供`fetch_for_product`與`fetch_for_parent`方法，這二個方法取產品返回一個`PurchaseInfo`實例。
```python
# partner/strategy.py

# A container for policies
PurchaseInfo = namedtuple(
    'PurchaseInfo', ['price', 'availability', 'stockrecord'])

```

策略類別在數個地方被取用。在模板中，一個`purchase_info_for_product`模板標記被用以載入價格與可用性資訊到template context:

```
{% load purchase_info_tags %}
{% load currency_filters %}

{% purchase_info_for_product request product as session %}

<p>
{% if session.price.is_tax_known %}
    Price is {{ session.price.incl_tax|currency:session.price.currency }}
{% else %}
    Price is {{ session.price.excl_tax|currency:session.price.currency }} +
    tax
{% endif %}
</p>
``` 
注意`currency` 模板標記接受一個流通參數自價格政策。

並且購物籃實例具有一個策略實例指向，所以它們可以計算含稅價格，這在購物藍中間體中自動完成。

### 這看起來相當複雜
While this probably seems like quite an involved way of looking up a product’s price, 並給予了開發者無限的彈性，這裡有一些例子，你可以對策略類別做的事。

* 用多種貨幣交易。策略類別可以使用消費者區域，以自一個區域庫存分消商中出貨，而使用消費者流通的貨幣。
* 優雅的處理不同稅務模型。
* 不同價格對不同的消費者。
* 使用一鏈鎖的供貨夥伴以供貨。

### API
所以的策略子類化自一個通用的`Base`類別。  
`class oscar.apps.partner.strategy.Base(request=None)`  
基礎策略類別  
對一種產品，策略們用以做為返回一`PurchaseInfo`實例，包含以下資訊。
* 對一消費者適當的庫存紀錄
* 一個價格政策實例
* 一個可得性政策實例

` fetch_for_line(line, stockrecord=None)`  
對一個購物籃連線實例，附加一個`PurchaseInfo`實例。

` fetch_for_parent(product)`
對一個父產品，附加一個`StockInfo`實例

` fetch_for_product(product, stockrecord=None)`
對一個產品，返回一個`PurchaseInfo`實例。
`PurchaseInfo`類別是一個具名的tuple，具三個屬性:
* `price`: 一個價格政策物件。
* `availability`: 一個可用性政策物件。
* `stockrecord`: 一個被使用的庫存紀錄。

If a stockrecord is passed, return the appropriate PurchaseInfo instance for that product and stockrecord is returned. ->不懂。


Oscar也提供`結構化`的策略類別，這對'選擇庫存紀錄'\'決定價格與可得性'提供一個可覆寫的方法。
` class oscar.apps.partner.strategy.Structured(request=None)`

A strategy class which provides separate, overridable methods for determining the 3 things that a `PurchaseInfo` instance requires:
1. A stockrecord
2. A pricing policy
3. An availability policy

` availability_policy(product, stockrecord)`
` fetch_for_product(product, stockrecord=None)`
` pricing_policy(product, stockrecord)`
` select_children_stockrecords(product)`
` select_stockrecord(product)`
For most projects, subclassing and overriding the Structured base class should be sufficient.  
However, Oscar also provides mixins to easily compose the appropriate strategy class for your domain.

### 載入一個策略

策略實例是由`Selector`類別所決定。

` class oscar.apps.partner.strategy.Selector`  
對一個user/session返回一個適當的策略實例。
可以被三個方式呼叫。

` strategy(request=None, user=None, **kwargs)`
返回一個實例化的策略實例。

### 價格政策
一個價格政策是一個簡單的類別，帶有數個屬性，它的工作是包含產品的所有的價格與稅金資訊。  
` class oscar.apps.partner.prices.Base`
The interface that any pricing policy must support

` currency = None # 貨幣種類`
` excl_tax = None # 不含稅價格`
` exists = False # 是否存在價格`
` incl_tax = None # 含稅價格`
` is_tax_known = False # 稅金是否已知`
` retail = None # 零售價格`
` tax = None # 稅金金額`

有數個政策，以完成通用的情境
` class oscar.apps.partner.prices.Unavailable`
` class oscar.apps.partner.prices.FixedPrice(currency, excl_tax, tax=None)`

Note that this price class uses the tax-exclusive price for offers, even if the tax is known. This may not be what you want. Use the TaxInclusiveFixedPrice class if you want offers to use tax-inclusive prices.

### 可得性政策
就像價格政策，可得性政策是一個簡單的類別，帶有數個屬性與方法。可得性政策的工作是對消費者提供可得性訊息，以及方法以決定產品可以被購買。
` class oscar.apps.partner.availability.Base`
Base availability policy.
` code = ''`
` dispatch_date = None`
` is_available_to_buy`
` is_purchase_permitted(quantity)`
` message = ''`
` short_message`
另外有些預定義的可得性政策:
` class oscar.apps.partner.availability.Unavailable`
` class oscar.apps.partner.availability.Available` -> 總是可得
` class oscar.apps.partner.availability.StockRequired(num_available)` -> 適合實體商品，沒有庫存就不能買

### 策略混合
Oscar also ships with several mixins which implement one method of the `Structured` strategy. These allow strategies to be easily composed from re-usable parts:

### 預設策略
Oscar's default `Selector` class returns a `Default` strategy built from the strategy mixins:

```python
class Default(UseFirstStockRecord, StockRequired, NoTax, Structured):
    pass
```
The behaviour of this strategy is:

* Always picks the first stockrecord (this is backwards compatible with Oscar<0.6 where a product could only have one stockrecord).
* Charge no tax.
* Only allow purchases where there is appropriate stock (eg no back-orders).


### 如何使用

有許多方式以使用策略，價格與可得性政策以處理你的領域要求。  
通常第一步是提供你自己的`Seletor`類別，以返回一個客製的策略類別，你的客製類別可以由上述mixin組成或你自己的客製邏輯。  
例1: UK VAT

在此為一個`strategy.py`模組，用以在價格上附加VAT。


例2: US sales tax  
Here's an example strategy.py module which is suitable for use in the US where taxes can't be calculated until the shipping address is known. You normally need to use a 3rd party service to determine taxes - details omitted here.

### django-oscar-demo 的第四單元提供了一個例子
原始的**django-oscar**`strategy.py`內直接將可用性及價格的類用`get_class`載入，供`strategy`類別進行組合，然藉由`Selector`返回被選擇的`strategy`。而strategy基類`class Base(object):`的 docstring 明確的解釋了strategy的作用就是要返回`PurchaseInfo instance`，原始的程式碼中，策略大都以`mixin`型式供`Selector`使用，例如
```python
class Default(UseFirstStockRecord, StockRequired, NoTax, Structured):
    """
    Default stock/price strategy that uses the first found stockrecord for a
    product, ensures that stock is available (unless the product class
    indicates that we don't need to track stock) and charges zero tax.
    """
```
在django-oscar-demo的例子
```python
# the strategy object usese multiple classes, each providing some of the functionality
class OscarDemoStrategy(
    UseFirstStockRecord,  # oscar allows multiple stockrecords for the same product
                          # this allows, for example, to have orders of a large quantity be made via a different supplier
                          # but for most cases, we just use the first stock record
    StockRequired,  # this is the basic availability policy strategy
                    # it ensures there is enough stock to allow purchasing the product
                    # also, in case of parent products - if no variants are available, the parent will not be available
    Structured,  # this is the main standard strategy class, providing a lot of common functionality
                 # let's have a look at it: https://github.com/django-oscar/django-oscar/blob/1.1.1/src/oscar/apps/partner/strategy.py#L101
                 # it defines the 2 main functions which any strategy requires -
                 # fetch_for_product and fetch_for_parent (product)
                 # it then returns a PurchaseInfo object containing the price and availability
):

    # here we define the pricing policy based on cost price
    # this will be used for most normal products, see below for parent products
    def pricing_policy(self, product, stockrecord):
        # Check stockrecord has the appropriate data
        if not stockrecord or stockrecord.cost_price is None:
            return PriceUnavailable()
        else:
            # we return our custom price object
            return CostBasedPrice(stockrecord.price_currency, stockrecord.cost_price)

    def parent_pricing_policy(self, product, children_stock):
        stockrecords = [x[1] for x in children_stock if x[1] is not None]
        if not stockrecords:
            return PriceUnavailable()
        else:
            # We take price from first record
            stockrecord = stockrecords[0]
            if stockrecord.cost_price is None:
                return PriceUnavailable()
            else:
                # we return our custom price object
                return CostBasedPrice(stockrecord.price_currency, stockrecord.cost_price)
```


